package com.sparta.travelconquestbe.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    // TTL 사용을 위한 외부 캐시 라이브러리 사용 'Caffeine'
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("searchPostsCache","searchPostsBestCache");
        cacheManager.setCaffeine(
                Caffeine.newBuilder()
                        // 캐시 TTL 설정
                        .expireAfterWrite(10, TimeUnit.MINUTES)
                        // 최대 캐시 엔트리 수
                        .maximumSize(1000)
        );
        return cacheManager;
    }
}
package com.sparta.travelconquestbe.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

	private static final String DEVELOP_FRONT_ADDRESS = "http://localhost:3000";

	@Override
	public void addCorsMappings(CorsRegistry registry) {
		registry.addMapping("/**")
			.allowedOrigins(DEVELOP_FRONT_ADDRESS)
			.allowedMethods("GET", "POST", "PUT", "DELETE")
			.exposedHeaders("location")
			.allowedHeaders("*")
			.allowCredentials(true);
	}
}
package com.sparta.travelconquestbe.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		// stomp 접속 URL : ws://localhost:8080/ws
		registry.addEndpoint("/ws") // socket 연결 url
			.setAllowedOriginPatterns("*") // CORS 허용 범위
			.withSockJS();
	}
	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		// 메시지를 구독(수신)하는 요청 엔드포인트
		registry.enableSimpleBroker("/sub");
		// 메시지를 발행(송신)하는 엔드포인트
		registry.setApplicationDestinationPrefixes("/pub"); // prefix 정의
	}
}
package com.sparta.travelconquestbe.config;

import com.querydsl.jpa.impl.JPAQueryFactory;
import jakarta.persistence.EntityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QueryDslConfig {

    private final EntityManager entityManager;

    public QueryDslConfig(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    @Bean
    public JPAQueryFactory jpaQueryFactory() {
        return new JPAQueryFactory(entityManager);
    }
}
package com.sparta.travelconquestbe;

import com.sparta.travelconquestbe.common.exception.CustomException;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.http.HttpStatus;

@EnableJpaAuditing
@SpringBootApplication
public class TravelConquestBeApplication {

    public static void main(String[] args) {
        SpringApplication.run(TravelConquestBeApplication.class, args);
    }

}
package com.sparta.travelconquestbe.common.validator;

import com.sparta.travelconquestbe.common.annotation.ValidEnum;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class ValueOfEnumValidator implements ConstraintValidator<ValidEnum, String> {
    private Class<? extends Enum<?>> enumClass;

    @Override
    public void initialize(ValidEnum constraintAnnotation) {
        this.enumClass = constraintAnnotation.enumClass();
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        for (Enum<?> enumConstant : enumClass.getEnumConstants()) {
            if (enumConstant.name().equals(value)) {
                return true;
            }
        }
        return false;
    }
}
package com.sparta.travelconquestbe.common.entity;

import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.Temporal;
import jakarta.persistence.TemporalType;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class TimeStampCreated {

    @CreatedDate
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;
}
package com.sparta.travelconquestbe.common.entity;

import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.Temporal;
import jakarta.persistence.TemporalType;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class TimeStampCreateUpdate {
    @CreatedDate
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime updatedAt;
}
package com.sparta.travelconquestbe.common.entity;

import jakarta.persistence.*;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class TimeStampAll {
    @CreatedDate
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime updatedAt;

    @Column
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime deletedAt;
}
package com.sparta.travelconquestbe.common.annotation;

import com.sparta.travelconquestbe.common.validator.ValueOfEnumValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Constraint(validatedBy = ValueOfEnumValidator.class)
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidEnum {
    Class<? extends Enum<?>> enumClass();

    String message() default "";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
package com.sparta.travelconquestbe.common.exception;

import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(CustomException.class)
    public ResponseEntity<ErrorResponse> handleCustomException(CustomException e) {
        return new ResponseEntity<>(ErrorResponse.builder().errorCode(e.getErrorCode()).errorMessage(e.getErrorMessage()).httpStatus(e.getHttpStatus().value()).timestamp(System.currentTimeMillis()).build(), e.getHttpStatus());
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        String errorMessage = ex.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        ErrorResponse response = new ErrorResponse("COMMON_001", errorMessage, 400, System.currentTimeMillis());
        return new ResponseEntity<>(response, HttpStatusCode.valueOf(response.getHttpStatus()));
    }
}
package com.sparta.travelconquestbe.common.exception;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import org.springframework.http.HttpStatus;

@Getter
@AllArgsConstructor
@Builder
public class CustomException extends RuntimeException {
    private final String errorCode;
    private final String errorMessage;
    private final HttpStatus httpStatus;
}
package com.sparta.travelconquestbe.common.exception;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@Builder
public class ErrorResponse {
    private String errorCode;
    private String errorMessage;
    private int httpStatus;
    private long timestamp;
}
package com.sparta.travelconquestbe.api.chat.dto.request;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ChatRoomCreateRequest {
	private String title;
	private int maxUsers;
	private String password;
}
package com.sparta.travelconquestbe.api.chat.dto.request;

public class SaveMessageRequest {
}
package com.sparta.travelconquestbe.api.chat.dto.respones;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ChatRoomEnterResponse {
	private boolean success;
	private String message;
}
package com.sparta.travelconquestbe.api.chat.dto.respones;

import com.sparta.travelconquestbe.domain.chat.entity.ChatRoom;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChatRoomCreateResponse {
	private Long id;
	private String title;
	private int maxUsers;
	private int currentUsers;
	private boolean hasPassword;

	public static ChatRoomCreateResponse fromChatRoom(ChatRoom chatRoom) {
		return ChatRoomCreateResponse.builder()
			.id(chatRoom.getId())
			.title(chatRoom.getTitle())
			.maxUsers(chatRoom.getMaxUsers())
			.currentUsers(chatRoom.getCurrentUsers())
			.hasPassword(chatRoom.isHasPassword())
			.build();
	}
}package com.sparta.travelconquestbe.api.chat.dto.respones;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ChatRoomExitResponse {
	private boolean success;
	private String message;
}
package com.sparta.travelconquestbe.api.chat.dto.respones;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ChatRoomSearchResponse {
	private Long id;            // 채팅방 ID
	private String title;       // 채팅방 제목
	private int maxUsers;       // 최대 사용자 수
	private int currentUsers;   // 현재 사용자 수
	private boolean hasPassword; // 비밀번호 사용 여부
}package com.sparta.travelconquestbe.api.chat.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.sparta.travelconquestbe.api.chat.dto.request.ChatRoomCreateRequest;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomCreateResponse;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomEnterResponse;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomExitResponse;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomSearchResponse;
import com.sparta.travelconquestbe.api.chat.service.ChatRoomService;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/chat/rooms")
public class ChatRoomController {

	private final ChatRoomService chatRoomService;

	// 채팅방 생성
	@PostMapping
	public ResponseEntity<ChatRoomCreateResponse> createRoom(@RequestBody ChatRoomCreateRequest request) {
		ChatRoomCreateResponse response = chatRoomService.createRoom(request);
		return ResponseEntity.ok(response);
	}

	@GetMapping
	public ResponseEntity<List<ChatRoomSearchResponse>> searchAllChatRooms() {
		List<ChatRoomSearchResponse> responses = chatRoomService.searchAllRooms();
		return ResponseEntity.ok(responses);
	}

	// 채팅방 입장 처리
	@MessageMapping("/enter/{chatRoomId}")  // /pub/enter/{chatRoomId} 로 요청이 들어오면 이 메서드가 호출됩니다.
	@SendTo("/sub/chatroom/{chatRoomId}")   // /sub/chatroom/{chatRoomId}로 메시지가 발송됩니다.
	public ChatRoomEnterResponse enterChatRoom(@DestinationVariable Long chatRoomId,
		@Header("userId") Long userId) {
		// 채팅방 입장 처리 서비스 호출
		chatRoomService.enterChatRoom(chatRoomId, userId);

		// 응답 메시지 생성 (채팅방에 입장한 후 응답을 클라이언트로 발송)
		return new ChatRoomEnterResponse(true, "채팅방에 입장했습니다.");
	}

	// 채팅방 퇴장 처리
	@MessageMapping("/exit/{chatRoomId}")  // /pub/exit/{chatRoomId}로 요청이 들어오면 이 메서드가 호출됩니다.
	@SendTo("/sub/chatroom/{chatRoomId}")  // /sub/chatroom/{chatRoomId}로 메시지가 발송됩니다.
	public ChatRoomExitResponse exitChatRoom(@DestinationVariable Long chatRoomId,
		@Header("userId") Long userId) {
		// 채팅방 퇴장 처리 서비스 호출
		chatRoomService.exitChatRoom(chatRoomId, userId);

		// 응답 메시지 생성 (채팅방에서 퇴장한 후 응답을 클라이언트로 발송)
		return new ChatRoomExitResponse(true, "채팅방에서 퇴장했습니다.");
	}
}

package com.sparta.travelconquestbe.api.chat.controller;

import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;

import com.sparta.travelconquestbe.api.chat.service.ChatService;
import com.sparta.travelconquestbe.domain.chat.entity.Chat;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Controller
public class ChatController {

	private final SimpMessagingTemplate messagingTemplate;
	private final ChatService chatService;

	// 메시지 받기 및 다른 클라이언트에게 전달하기
	@MessageMapping("/chat/{roomId}")
	@SendTo("/sub/chat/{roomId}")
	public Chat sendMessage(@DestinationVariable Long roomId, Chat message) {
		// DB 저장
		chatService.sendMessage(roomId, message);

		// 클라이언트에게 메시지 전달
		// messagingTemplate.convertAndSend("/sub/chat/" + roomId, message);
		return message;
	}


	// 직접 메시지를 특정 채팅방에 전송하는 메소드
	public void sendMessageToRoom(String roomId, Chat message) {
		messagingTemplate.convertAndSend("/sub/chat/" + roomId, message);
	}
}
package com.sparta.travelconquestbe.api.chat.service;

import static org.springframework.http.HttpStatus.*;

import java.util.List;

import org.springframework.stereotype.Service;

import com.sparta.travelconquestbe.api.chat.dto.request.ChatRoomCreateRequest;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomCreateResponse;
import com.sparta.travelconquestbe.api.chat.dto.respones.ChatRoomSearchResponse;
import com.sparta.travelconquestbe.common.exception.CustomException;
import com.sparta.travelconquestbe.domain.chat.entity.ChatRoom;
import com.sparta.travelconquestbe.domain.chat.repository.ChatRoomRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ChatRoomService {

	private final ChatRoomRepository chatRoomRepository;


	// 채팅방 생성
	public ChatRoomCreateResponse createRoom(ChatRoomCreateRequest request) {
		ChatRoom chatRoom = ChatRoom.builder()
			.title(request.getTitle())
			.maxUsers(request.getMaxUsers())
			.password(request.getPassword())
			.build();

		ChatRoom savedChatRoom = chatRoomRepository.save(chatRoom);
		return ChatRoomCreateResponse.fromChatRoom(savedChatRoom);
	}

	public List<ChatRoomSearchResponse> searchAllRooms() {
		return chatRoomRepository.findAll().stream()
			.map(chatRoom -> new ChatRoomSearchResponse(
				chatRoom.getId(),
				chatRoom.getTitle(),
				chatRoom.getMaxUsers(),
				chatRoom.getCurrentUsers(),
				chatRoom.isHasPassword()))
			.toList();
	}


	// 채팅방 입장 로직
	public void enterChatRoom(Long chatRoomId, Long userId) {
		// 1. 채팅방이 존재하는지 확인
		ChatRoom chatRoom = chatRoomRepository.findById(chatRoomId)
			.orElseThrow(() -> new RuntimeException("채팅방이 존재하지 않습니다."));

		// 2. 채팅방 입장 시 현재 사용자 수 증가
		chatRoom.setCurrentUsers(chatRoom.getCurrentUsers() + 1);

		// 3. 변경된 채팅방 데이터를 저장
		chatRoomRepository.save(chatRoom);
	}

	// 채팅방 퇴장 로직
	public void exitChatRoom(Long chatRoomId, Long userId) {
		// 1. 채팅방이 존재하는지 확인
		ChatRoom chatRoom = chatRoomRepository.findById(chatRoomId)
			.orElseThrow(() -> new RuntimeException("채팅방이 존재하지 않습니다."));

		// 2. 채팅방 퇴장 시 현재 사용자 수 감소
		if (chatRoom.getCurrentUsers() > 0) {
			chatRoom.setCurrentUsers(chatRoom.getCurrentUsers() - 1);
		} else {
			throw new RuntimeException("채팅방에 아무도 없습니다.");
		}

		// 3. 변경된 채팅방 데이터를 저장
		chatRoomRepository.save(chatRoom);
	}
}
package com.sparta.travelconquestbe.api.chat.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import com.sparta.travelconquestbe.domain.chat.entity.Chat;
import com.sparta.travelconquestbe.domain.chat.entity.ChatRoom;
import com.sparta.travelconquestbe.domain.chat.repository.ChatRepository;
import com.sparta.travelconquestbe.domain.chat.repository.ChatRoomRepository;

import lombok.RequiredArgsConstructor;

@Service
public class ChatService {

	private final ChatRepository chatRepository;
	private final SimpMessagingTemplate messagingTemplate;
	private final ChatRoomRepository chatRoomRepository;

	@Autowired
	public ChatService(ChatRepository chatRepository, ChatRoomRepository chatRoomRepository, SimpMessagingTemplate messagingTemplate) {
		this.chatRepository = chatRepository;
		this.messagingTemplate = messagingTemplate;
		this.chatRoomRepository = chatRoomRepository;
	}

	public Chat sendMessage(Long roomId, Chat message) {
		// 채팅방 ID와 메시지를 처리하는 로직

		// 채팅방 ID로 채팅방을 찾아서 채팅 메시지를 저장
		ChatRoom chatRoom = chatRoomRepository.findById(roomId)
			.orElseThrow(() -> new IllegalArgumentException("Invalid room ID"));

		// Chat 엔티티로 메시지 저장
		Chat chat = Chat.builder()
			.chatRoom(chatRoom)
			.nickname(message.getNickname())
			.message(message.getMessage())
			.build();

		chatRepository.save(chat); // DB에 메시지 저장

		// 메시지를 구독자에게 전송
		messagingTemplate.convertAndSend("/sub/chat/" + roomId, message);
		return chat;
	}
}
package com.sparta.travelconquestbe.domain.bookmark.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.route.entity.Route;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "bookmarks")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Bookmark extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "route_id")
    private Route route;
}
package com.sparta.travelconquestbe.domain.route.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreateUpdate;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "routes")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Route extends TimeStampCreateUpdate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false,length = 255)
    private String title;

    @Column(nullable = false,columnDefinition = "TEXT")
    private String description;

    private Long totalDistance;

    private int money;

    private String estimatedTime;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}
package com.sparta.travelconquestbe.domain.chat.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.sparta.travelconquestbe.domain.chat.entity.ChatRoom;

public interface ChatRoomRepository extends JpaRepository<ChatRoom, Long> {
}
package com.sparta.travelconquestbe.domain.chat.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.sparta.travelconquestbe.domain.chat.entity.Chat;

public interface ChatRepository extends JpaRepository<Chat, Long> {
}
package com.sparta.travelconquestbe.domain.chat.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "chatrooms")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ChatRoom {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	@Column(nullable = false)
	private String title; // 채팅방 제목

	@Column(nullable = false)
	private int maxUsers; // 최대 사용자 수

	@Column
	private String password; // 비밀번호 (선택)

	@Column(nullable = false)
	private boolean hasPassword; // 비밀번호 사용 여부

	@Column(nullable = false)
	private int currentUsers = 0; // 현재 사용자 수 (기본값 0)

	@Builder
	public ChatRoom(String title, int maxUsers, String password) {
		this.title = title;
		this.maxUsers = maxUsers;
		this.password = password;
		this.hasPassword = (password != null && !password.isEmpty());
	}

	// 현재 사용자 증가
	public void addUser() {
		if (currentUsers >= maxUsers) {
			throw new IllegalStateException("채팅방 정원이 초과되었습니다.");
		}
		this.currentUsers++;
	}

	// 현재 사용자 감소
	public void removeUser() {
		if (currentUsers > 0) {
			this.currentUsers--;
		}
	}
}package com.sparta.travelconquestbe.domain.chat.entity;

import java.time.LocalDateTime;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;


@Entity
@Table(name = "chats")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Chat extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "chat_room_id", nullable = false)
    private ChatRoom chatRoom; // 채팅방과의 관계

    @Column(nullable = false)
    private String nickname; // 작성자 닉네임

    @Column(nullable = false)
    private String message; // 메시지 내용
}package com.sparta.travelconquestbe.domain.notification.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "notifications")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Notification extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 255)
    private String message;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}
package com.sparta.travelconquestbe.domain.mycoupon.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.coupon.entity.Coupon;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.ColumnDefault;

@Entity
@Table(name = "mycoupons")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MyCoupon extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ColumnDefault(value = "false")
    private boolean useStatus;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "coupon_id")
    private Coupon coupon;
}
package com.sparta.travelconquestbe.domain.admin.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampAll;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "admins")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Admin extends TimeStampAll {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String email;

    @Column(nullable = false, length = 255)
    private String password;
}
package com.sparta.travelconquestbe.domain.user.entity;

import com.sparta.travelconquestbe.domain.user.enums.Title;
import com.sparta.travelconquestbe.domain.user.enums.UserType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 30)
    private String name;

    @Column(nullable = false, length = 30)
    private String nickname;

    @Column(nullable = false, unique = true, length = 50)
    private String email;

    @Column(nullable = false, length = 255)
    private String password;

    private Long providerId;

    @Column(nullable = false, length = 10)
    private String birth;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserType type;

    @Enumerated(EnumType.STRING)
    private Title title;

    // Custom Methods
    public void changeNickname(String newNickname) {
        this.nickname = newNickname;
    }

    public void changePassword(String newPassword) {
        this.password = newPassword;
    }

    public void changeUserType(UserType newType) {
        this.type = newType;
    }
}
package com.sparta.travelconquestbe.domain.user.enums;

public enum Title {
    TRAVELER,
    PIONEER,
    CONQUEROR
}
package com.sparta.travelconquestbe.domain.user.enums;

public enum UserType {
    USER,
    AUTHENTICATED_USER,
    ADMIN
}
package com.sparta.travelconquestbe.domain.coupon.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreateUpdate;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Entity
@Table(name = "coupons")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Coupon extends TimeStampCreateUpdate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 30)
    private String name;

    private String description;

    @Column(nullable = false)
    private int discount_amount;

    @Column(nullable = false)
    private LocalDate valid_until;

    @Column(nullable = false)
    private int count;
}
package com.sparta.travelconquestbe.domain.subscription.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "subscriptions")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Subscription extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long userId;

    @Column(nullable = false)
    private Long subUserId;
}
package com.sparta.travelconquestbe.domain.routelocation.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.route.entity.Route;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Entity
@Table(name = "routelocations")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RouteLocation extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 255)
    private String locationName;

    @Column(nullable = false)
    private int sequence;

    @Column(name = "latitude", nullable = false, precision = 10, scale = 8)
    private BigDecimal latitude;  // 위도

    @Column(name = "longitude", nullable = false, precision = 11, scale = 8)
    private BigDecimal longitude;  // 경도

    @ManyToOne
    @JoinColumn(name = "route_id")
    private Route route;
}
package com.sparta.travelconquestbe.domain.review.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.route.entity.Route;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "reviews")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Review extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int rating;

    @Column(columnDefinition = "TEXT")
    private String comment;

    @ManyToOne
    @JoinColumn(name = "route_id")
    private Route route;

    @ManyToOne
    @JoinColumn(name="user_id")
    private User user;
}
package com.sparta.travelconquestbe.domain.report.entity;

import com.sparta.travelconquestbe.common.entity.TimeStampCreated;
import com.sparta.travelconquestbe.domain.admin.entity.Admin;
import com.sparta.travelconquestbe.domain.report.enums.Reason;
import com.sparta.travelconquestbe.domain.report.enums.ReportCategory;
import com.sparta.travelconquestbe.domain.report.enums.Villain;
import com.sparta.travelconquestbe.domain.user.entity.User;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "reports")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Report extends TimeStampCreated {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ReportCategory reportCategory;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Reason reason;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Villain status;

    @Column(nullable = false)
    private LocalDateTime checkedAt;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne
    @JoinColumn(name = "admin_id", nullable = false)
    private Admin admin;
}
package com.sparta.travelconquestbe.domain.report.enums;

public enum ReportCategory {
    ROUTE, REVIEW, CHAT
}
package com.sparta.travelconquestbe.domain.report.enums;

public enum Villain {
    SAINT, OUTLAW
}
package com.sparta.travelconquestbe.domain.report.enums;

public enum Reason {
    PROFANITY,      // 욕설
    ADVERTISING,    // 광고
    MISINFORMATION, // 거짓정보
    SPAM            // 도배
}
